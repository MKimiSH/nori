<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" type="image/vnd.microsoft.icon" href="../favicon.ico" />

    <title>Computer Graphics - PA4</title>

    <link href="resources/bootstrap.min.css" rel="stylesheet">
    <link href="resources/offcanvas.css" rel="stylesheet">
    <link href="resources/custom2014.css" rel="stylesheet">
    <link href="resources/twentytwenty.css" rel="stylesheet" type="text/css" />
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>

<body>

<div class="container headerBar">
		<h1>Project Proposal - Niklaus Houska & Alessia Paccagnella</h1>
</div>

<div class="container contentWrapper">
<div class="pageContent">

	<!-- ================================================================= -->

	<h2>Niklaus</h2>

  <h2>1. Heterogeneous Participating Media </h2>

    Relevant classes
    <br>
    <code> medium.h/.cpp </code> <br>
    <code> PhaseFunction.h/.cpp </code> <br>
    <code> vol_path.cpp </code> <br>
    <br>

    In following section the implementation of the heterogeneous medium and
    the volumetric path tracer (mis) are presented.

    <h3>Medium </h3>

    Our medium is described by the absorption and scattering coefficients <code> sigma_a </code> and <code> sigma_s </code> and
    a phase function. <code> sigma_t </code> the extinction coefficient and
    the color <code> albedo </code> can be derived from <code> sigma_a </code> and <code> sigma_s </code>. Each point in the medium
    has a density value determined by a function of choice. For simplicity the medium is bounded by a parameterized box,
    such that density evaluates to 0 outside the box.
    <br>
    We need two main functionalities from our medium class. We need to be able to sample an medium interaction given a ray
    and be able to determine the transmittance along a ray. To sample a medium interaction, we take a random step along the ray
    according to <code> -log(1 - random) / sigma_t </code>. Where random is a number between 0 and 1. If the normalized density
    at the observed spot is bigger than another random number, we report the medium interaction and return the interaction
    color <code> albedo * density_at_location </code>, else we continue. If the end
    of the ray is reached or the bounding box is exited, no medium interaction is made.
    <br>
    The transmittance is caluclated similarly. We step along the ray according to <code> -log(1 - random) / sigma_t </code>
    until we reach the end of the ray or leave the mediums bounding box. At each step we multiply the initial transmittance of
    1 by <code> 1 - density_at_location </code> where the density is normalized to lie between 0 and 1.

    <br>
    For the density function I implemeted a simple exponential decay function <code> a * exp(-b*h) </code>.
    <br> <br>
    <code> sigma_a = 0.2 </code> and <code> sigma_s = 2 </code>. Sample count 1024.

  <img src="imagesNik/cbox_path_vol_exp.png"  alt="Example 1">

    <h3> Volumetric Path Tracer </h3>

    The path tracer is the core of the whole and took the most time to implement. As we are interested in a multiple importance
    sampler, I started by extending the MIS-path tracer already implemented in the exercises. Outline of the changed code:
    <br>
<pre>
t = (1,1,1), w_mats = 1
rayIntersect(...)
while (true)
    mediumColor = medium->sample_interaction(ray)
    if (medium interaction)

        pdf_mat, wo = sample_phaseFunction(ray)

        sample light and get pdf_ems
        if (shadowRay unoccluded)
            t *= mediumColor
            result += t * transmittance_to_light * pdf_mat * light_sample

        Russian Roulette

        ray = new Ray (origin=medium interaction, direction=wo)
        new w_mats weight if new intersection is emitter

    else if (not ray intersected)
        return result

    else
        -- Here comes surface interaction. Same as in path-mis except added transmission term to each light contribution
        -- and except that we dont return if the new ray does not intersect the scene
        -- to allow a further medium interaction
</pre>
<h3> Validation </h3>
Here a comparison between the new integrator without a medium and the old mis path tracer. They are identical.
<br>
  <div class="twentytwenty-container">
      <img src="imagesNik/cbox_path_mis.png" alt="Old MIS" class="img-responsive">
      <img src="imagesNik/cbox_path_vol.png" alt="Volumetric" class="img-responsive">
  </div> <br>

    Next we show comparison of mitsuba with mine solution. The scenes geometry is not 100% identical due to conversion issues.
    <br>
    <code> sigma_a = 1 </code> and <code> sigma_s = 2 </code>. Sample count 256.
  <div class="twentytwenty-container">
      <img src="imagesNik/cbox_path_vol_m.png" alt="Mitsuba volpath_simple" class="img-responsive">
      <img src="imagesNik/cbox_path_vol_mc.png" alt="Mine vol_path" class="img-responsive">
  </div> <br>

<h2> Bump Mapping </h2>
    Relevant classes
    <br>
    <code> normaltexture.cpp </code> <br>
    <code> vol_path.cpp </code> <br>
    <code> path_mis.cpp </code> <br>
    <br>
    Here I implemented a simple normal map texture. The color channels of the normal map are transformed into normal vector
    components according to <code> 2 * c - 1 </code>. The normal texture is added as a nested texture to any bsdf and the uv
    coordinate is used to look up the value. Furthermore, the texture can be scaled in the same way as the image texture.
    <br>
    The main integrators <code> vol_path </code> and <code> path_mis </code> where adapted to construct the new coordinate frame
    based on the looked up normal.
    <br> Below is a comparison of the normal maps effect. The images in the bottom row have a constant normal map evaluating to (0,0,1) everywhere.

    <div class="twentytwenty-container">
      <img src="imagesNik/material_no_tex.png" alt="Plain normal" class="img-responsive">
      <img src="imagesNik/material_tex_norm.png" alt="Texture + normal" class="img-responsive">
      <img src="imagesNik/material_ref1.png" alt="Plain reference" class="img-responsive">
      <img src="imagesNik/material_ref2.png" alt="Texture reference" class="img-responsive">
  </div> <br>

<h2> 3. Textured Emitter </h2>
    Relevant classes
    <br>
    <code> arealight.cpp </code>
    <br><br>
    To make textured emitters work, I added the functionality to add a texture to the area emitter. The area emitter is
    not anymore limited to a constant color but can use the uv coordinates to look up the radiance of a specified point.
    For this I added the possibility to pass uv coordinates within the EmitterQueryRecord and adapted the integrators to do so.
    <br>
    Below you see Suzanne (Blenders monkey) having a checkerboard textured area emitter as texture. Rendered using vol_path in light fog.
    <img src="imagesNik/texture_emitter.png" alt="Texture 1">
<br><br>
<h2> 4. Disney BRDF </h2>
    Relevant classes
    <br>
    <code> disney.cpp </code><br>
    <code> warp.cpp </code>
    <h3> BRDF evaluation </h3>
    The evaluation of the brdf for a given pair of direction was implemented with help of
    <a href = "https://disney-animation.s3.amazonaws.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf"> this</a>.
    I implemented the diffuse, roughness, specularity + tint, metallic and clearcoat + gloss parameters. Omitting subsurface
    scattering and anisotropic effects. There exist several small variants to the diffuse and specularity implementation, which I
    think comes due to artist preference. To describe the specular lobes we need two variants of the Generalized-Trowbridge-Reit
    distribution (or GTR), one for the specularity term (GTR2) and another one for the clearcoat term (GTR1). The SquareToGTR1/2 functions
    where added to the warp classes and verified using warptest as seen later in the report. Noteworthy is that we square the roughness parameter
    for the specularity evaluation, many materials show very low roughness values and the squaring makes it more natural to arrive
    to them. Clearcoat uses a hardcoded range of roughness adjustable through the clearcoat gloss parameter.
    <br><br>
    Below each image sequence varies one parameter while keeping the others constant. <br>
    Metallic (1, pink), Specular (2, blue), Specular Tint (3, yellow), Roughness (4, green), Clearcoat (5, red), Clearcoat Gloss (6, red)

    <br>
    <img src="" width = 150 height = 20 alt="0.0"><img src="" width = 150 height = 20 alt="0.1"><img src="" width = 150 height = 20 alt="0.3"><img src="" width = 150 height =20 alt="0.5"><img src="" width = 150 height = 20 alt="0.7"><img src="" width = 150 height = 20 alt="0.9"><img src="" width = 150 height = 20 alt="1.0">
    <br>
    <img src="imagesNik/metal00_.png" width = 150 height = 150 alt="00"><img src="imagesNik/metal01_.png" width = 150 height = 150 alt="00"><img src="imagesNik/metal03_.png" width = 150 height = 150 alt="00"><img src="imagesNik/metal05_.png" width = 150 height = 150 alt="00"><img src="imagesNik/metal07_.png" width = 150 height = 150 alt="00"><img src="imagesNik/metal09_.png" width = 150 height = 150 alt="00"><img src="imagesNik/metal10_.png" width = 150 height = 150 alt="00">
    <br>
    <img src="imagesNik/specular00_.png" width = 150 height = 150 alt="00"><img src="imagesNik/specular01_.png" width = 150 height = 150 alt="00"><img src="imagesNik/specular03_.png" width = 150 height = 150 alt="00"><img src="imagesNik/specular05_.png" width = 150 height = 150 alt="00"><img src="imagesNik/specular07_.png" width = 150 height = 150 alt="00"><img src="imagesNik/specular09_.png" width = 150 height = 150 alt="00"><img src="imagesNik/specular10_.png" width = 150 height = 150 alt="00">
    <br>
    <img src="imagesNik/tint00_.png" width = 150 height = 150 alt="00"><img src="imagesNik/tint01_.png" width = 150 height = 150 alt="00"><img src="imagesNik/tint03_.png" width = 150 height = 150 alt="00"><img src="imagesNik/tint05_.png" width = 150 height = 150 alt="00"><img src="imagesNik/tint07_.png" width = 150 height = 150 alt="00"><img src="imagesNik/tint09_.png" width = 150 height = 150 alt="00"><img src="imagesNik/tint10_.png" width = 150 height = 150 alt="00">
    <br>
    <img src="imagesNik/rough00_.png" width = 150 height = 150 alt="00"><img src="imagesNik/rough01_.png" width = 150 height = 150 alt="00"><img src="imagesNik/rough03_.png" width = 150 height = 150 alt="00"><img src="imagesNik/rough05_.png" width = 150 height = 150 alt="00"><img src="imagesNik/rough07_.png" width = 150 height = 150 alt="00"><img src="imagesNik/rough09_.png" width = 150 height = 150 alt="00"><img src="imagesNik/rough10_.png" width = 150 height = 150 alt="00">
    <br>
    <img src="imagesNik/coat00_.png" width = 150 height = 150 alt="00"><img src="imagesNik/coat01_.png" width = 150 height = 150 alt="00"><img src="imagesNik/coat03_.png" width = 150 height = 150 alt="00"><img src="imagesNik/coat05_.png" width = 150 height = 150 alt="00"><img src="imagesNik/coat07_.png" width = 150 height = 150 alt="00"><img src="imagesNik/coat09_.png" width = 150 height = 150 alt="00"><img src="imagesNik/coat10_.png" width = 150 height = 150 alt="00">
    <br>
    <img src="imagesNik/gloss00_.png" width = 150 height = 150 alt="00"><img src="imagesNik/gloss01_.png" width = 150 height = 150 alt="00"><img src="imagesNik/gloss03_.png" width = 150 height = 150 alt="00"><img src="imagesNik/gloss05_.png" width = 150 height = 150 alt="00"><img src="imagesNik/gloss07_.png" width = 150 height = 150 alt="00"><img src="imagesNik/gloss09_.png" width = 150 height = 150 alt="00"><img src="imagesNik/coat10_.png" width = 150 height = 150 alt="00">
    <br>

    To compare the implementation with a reference, I took the Principled BSDF of blender 
    <div class="twentytwenty-container">
      <img src="imagesNik/disneyref1.png" alt="Blender Principled BSDF" class="img-responsive">
      <img src="imagesNik/disneycomp1.png" alt="Disney BRDF" class="img-responsive">
  </div> <br>
    <
    <br>
    <img src="imagesNik/GTR1.png" width = 256 height = 200 alt="GTR1">
    <img src="imagesNik/GTR1pdf.png" width =256 height = 200 alt="GTR1 pdf">
     <img src="imagesNik/GTR2.png" width = 256 height = 200 alt="GTR1">
    <img src="imagesNik/GTR2pdf.png" width = 256 height = 200 alt="GTR1 pdf">

</div>
</div>


<!-- Bootstrap core JavaScript -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
<script src="resources/bootstrap.min.js"></script>
<script src="/js/offcanvas.js"></script>
<script src="resources/jquery.event.move.js"></script>
<script src="resources/jquery.twentytwenty.js"></script>


<script>
$(window).load(function(){$(".twentytwenty-container").twentytwenty({default_offset_pct: 0.5});});
</script>

</body>
</html>
